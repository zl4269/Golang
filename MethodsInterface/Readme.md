这里介绍的内容主要是方法集合决定接口实现：

1.如果某个自定义类型T的方法集合是某个接口类型的方法集合的超集，那么就说类型T实现了该接口，并且类型T变量可以赋值给该接口类型的变量。这就是方法集合决定接口的实现。
要判断自定义类型是否实现了某个接口类型，就要识别自定义类型和接口类型的方法集合。
        对于非接口类型的自定义类型T，其方法集合为所有receiver为T类型的方法组成
        而类型*T的方法集合则包含所有receiver为T和*T类型的方法。

2.接口类型与结构体类型相关的嵌入式有三种组合：
1)在接口类型中嵌入接口类型
2)在结构体类型中嵌入接口类型
3)在结构体类型汇总嵌入结构体类型


3.当结构体嵌入多个接口类型而且这些接口类型存在交集的时候，Go调用的顺序如下
1)优先选择结构体自身实现的方法
2)如果结构体自身没有实现，那么查找结构体中嵌入接口类型的方法集合中是否有该方法，如果有，则提升为该结构体方法
3)如果结构体嵌入了多个类型且这些接口类型方法集合存在交集，那么Go编译器将会报错，除非结构体实现了交集中的所有方法

4.在结构体中嵌入结构体
注意两点：
1)新的结构体能够调用被嵌入结构体的所有方法。
2)虽然新的结构体能够调用所有的方法，但是对于新的结构体，T和T*类型的方法集合还是有差被的，取决于嵌入的形式
如：嵌入体{T1  *T2}
则：T类型的方法集合 = T1 的方法集合 + *T2的方法集合
   *T类型的方法集合 = *T1 的方法集合 + *T2的方法集合
通俗的记忆成：T类型的方法集合等于继承的嵌入体。*T的方法集合等于嵌入体所有的方法集合


5.对于defined重新定义的结构体 (eg: type myint int)
1)如果重新定义的是非接口类型，则没有继承原类型的方法集合,新的defined类型的方法集合是空的
2)如果定义的是接口类型，则defined类型的方法和原类型的方法集合是一致的

6.类型别名的方法集合(eg: type myint=int)(通俗记忆都是一样的)



























